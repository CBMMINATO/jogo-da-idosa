<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jogando</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="container">
    <h1>‚≠ï Jogo da Velha ‚ùå</h1>

    <!-- Card dos jogadores com s√≠mbolos, nomes e contador de pe√ßas -->
    <div class="players-box-game">
      <!-- Jogador 1 (Host) - Sempre √© X -->
      <div class="player-card-game" id="player1Card">
        <div class="player-symbol">‚ùå</div>
        <div class="player-name-game" id="player1Name"></div>
        <div class="pieces-count" id="player1Pieces">Pe√ßas: 3</div>
      </div>
      <!-- Jogador 2 (Guest) - Sempre √© O -->
      <div class="player-card-game" id="player2Card">
        <div class="player-symbol">‚≠ï</div>
        <div class="player-name-game" id="player2Name"></div>
        <div class="pieces-count" id="player2Pieces">Pe√ßas: 3</div>
      </div>
    </div>

    <!-- Status principal do jogo (mostra de quem √© a vez e o que fazer) -->
    <div class="status-box" id="gameStatus">Coloque suas pe√ßas!</div>
    
    <!-- Informa√ß√£o da fase atual (Coloca√ß√£o ou Movimento) -->
    <div class="phase-info" id="phaseInfo">Fase de Coloca√ß√£o (3 pe√ßas cada)</div>

    <!-- Tabuleiro 3x3 (9 c√©lulas) -->
    <div class="board" id="board"></div>

    <!-- Bot√£o para sair do jogo -->
    <div class="button-group">
      <button onclick="leaveGame()" class="btn-danger">
        Sair do Jogo
      </button>
    </div>
  </div>

  <!-- Biblioteca do Supabase (banco de dados em tempo real) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Configura√ß√£o do Supabase (URL e chave de API) -->
  <script src="supabase.js"></script>
  
  <script>
    // ===== VARI√ÅVEIS GLOBAIS =====
    // Recupera informa√ß√µes salvas no navegador (localStorage)
    const roomCode = localStorage.getItem('roomCode');        // C√≥digo da sala (ex: ABC123)
    const playerName = localStorage.getItem('playerName');    // Nome do jogador atual
    const playerId = localStorage.getItem('playerId');        // ID √∫nico do jogador
    const isHost = localStorage.getItem('isHost') === 'true'; // Se √© o criador da sala
    let subscription = null;    // Conex√£o em tempo real com o Supabase
    let selectedPiece = null;   // Armazena qual pe√ßa est√° selecionada na fase de movimento

    // Se n√£o tiver informa√ß√µes salvas, volta para a tela inicial
    if (!roomCode || !playerName || !playerId) {
      window.location.href = 'index.html';
    }

    // ===== BUSCAR E EXIBIR NOMES DOS JOGADORES =====
    async function loadPlayerNames() {
      // Busca informa√ß√µes da sala no banco de dados
      const { data: room } = await supabase
        .from('rooms')
        .select('*')
        .eq('id', roomCode)
        .single();

      if (!room) return;

      // Buscar nome do host (criador da sala)
      let hostName = 'Host';
      if (room.host_name) {
        hostName = room.host_name;
      }

      // Buscar nome do guest (convidado)
      let guestName = 'Convidado';
      if (room.guest_name) {
        guestName = room.guest_name;
      }

      // Configurar nomes na tela
      // Se voc√™ √© o host, mostra "(Voc√™)" no seu nome
      if (isHost) {
        document.getElementById('player1Name').textContent = hostName + ' (Voc√™)';
        document.getElementById('player2Name').textContent = guestName;
      } else {
        // Se voc√™ √© o guest, mostra "(Voc√™)" no seu nome
        document.getElementById('player1Name').textContent = hostName;
        document.getElementById('player2Name').textContent = guestName + ' (Voc√™)';
      }
    }

    // ===== CRIAR TABULEIRO (9 C√âLULAS) =====
    const boardEl = document.getElementById('board');
    for (let i = 0; i < 9; i++) {
      const cell = document.createElement('button');       // Cria um bot√£o
      cell.className = 'cell';                            // Adiciona classe CSS
      cell.dataset.index = i;                             // Marca a posi√ß√£o (0 a 8)
      cell.onclick = () => handleCellClick(i);            // Define o que fazer ao clicar
      boardEl.appendChild(cell);                          // Adiciona ao tabuleiro
    }

    // ===== INSCREVER-SE EM MUDAN√áAS EM TEMPO REAL =====
    async function subscribeToGame() {
      // Carrega nomes dos jogadores
      await loadPlayerNames();
      
      // Atualiza o tabuleiro pela primeira vez
      await updateBoard();

      // Cria um canal de comunica√ß√£o em tempo real com o Supabase
      // Toda vez que a sala for atualizada, a fun√ß√£o updateBoard() √© executada
      subscription = supabase
        .channel('game-' + roomCode)                     // Canal √∫nico para esta sala
        .on('postgres_changes',                           // Escuta mudan√ßas no banco
          { 
            event: 'UPDATE',                              // Tipo: atualiza√ß√£o
            schema: 'public',                             // Schema do banco
            table: 'rooms',                               // Tabela: rooms
            filter: `id=eq.${roomCode}`                   // Filtra apenas esta sala
          },
          async () => {
            await updateBoard();                          // Atualiza tela quando houver mudan√ßa
          }
        )
        .subscribe();                                     // Ativa a inscri√ß√£o
    }

    // ===== ATUALIZAR TABULEIRO E INTERFACE =====
    async function updateBoard() {
      // Busca dados atualizados da sala no banco
      const { data: room } = await supabase
        .from('rooms')
        .select('*')
        .eq('id', roomCode)
        .single();

      if (!room) return;

      // Board √© um array com 9 posi√ß√µes: ['X', '', 'O', '', '', '', '', '', '']
      const board = room.board;
      const cells = document.querySelectorAll('.cell');   // Pega todas as c√©lulas do tabuleiro

      // ===== CONTAR PE√áAS NO TABULEIRO =====
      // Conta quantas pe√ßas X e O existem no tabuleiro
      const xPieces = board.filter(cell => cell === 'X').length;
      const oPieces = board.filter(cell => cell === 'O').length;

      // ===== ATUALIZAR CONTADOR DE PE√áAS =====
      // Mostra quantas pe√ßas cada jogador ainda pode colocar (3 - pe√ßas j√° colocadas)
      document.getElementById('player1Pieces').textContent = `Pe√ßas: ${3 - xPieces}/3`;
      document.getElementById('player2Pieces').textContent = `Pe√ßas: ${3 - oPieces}/3`;

      // ===== DETERMINAR FASE DO JOGO =====
      // Fase de Coloca√ß√£o: enquanto algum jogador tiver menos de 3 pe√ßas
      // Fase de Movimento: quando ambos tiverem colocado suas 3 pe√ßas
      const placementPhase = xPieces < 3 || oPieces < 3;

      // ===== ATUALIZAR C√âLULAS DO TABULEIRO =====
      cells.forEach((cell, i) => {
        const value = board[i];  // Pega o valor da posi√ß√£o (X, O ou vazio)
        
        // Define o conte√∫do visual da c√©lula
        cell.textContent = value === 'X' ? '‚ùå' : value === 'O' ? '‚≠ï' : '';
        
        // Remove todas as classes e adiciona a b√°sica
        cell.className = 'cell';
        if (value === 'X') cell.classList.add('x');      // Adiciona cor vermelha
        if (value === 'O') cell.classList.add('o');      // Adiciona cor azul
        
        // Se esta pe√ßa est√° selecionada, destaca com amarelo
        if (selectedPiece === i) {
          cell.classList.add('selected');
        }
      });

      // ===== VERIFICAR DE QUEM √â A VEZ =====
      // Compara se o current_turn da sala corresponde ao tipo do jogador (host/guest)
      const myTurn = (isHost && room.current_turn === 'host') || 
                     (!isHost && room.current_turn === 'guest');
      const mySymbol = isHost ? 'X' : 'O';               // S√≠mbolo do jogador atual

      // ===== ATUALIZAR MENSAGENS DE STATUS =====
      if (placementPhase) {
        // FASE DE COLOCA√á√ÉO
        const myPiecesLeft = isHost ? (3 - xPieces) : (3 - oPieces);
        document.getElementById('phaseInfo').textContent = `Fase de Coloca√ß√£o (${myPiecesLeft} pe√ßas restantes)`;
        document.getElementById('gameStatus').textContent = myTurn ? 'üéÆ Sua vez - Coloque uma pe√ßa!' : '‚è≥ Oponente colocando pe√ßa...';
      } else {
        // FASE DE MOVIMENTO
        document.getElementById('phaseInfo').textContent = 'Fase de Movimento (mova suas pe√ßas)';
        if (selectedPiece !== null) {
          // Se j√° selecionou uma pe√ßa, pede para escolher destino
          document.getElementById('gameStatus').textContent = 'üìç Escolha onde mover a pe√ßa!';
        } else {
          // Se n√£o selecionou, pede para selecionar uma pe√ßa
          document.getElementById('gameStatus').textContent = myTurn ? 'üéÆ Sua vez - Selecione uma pe√ßa!' : '‚è≥ Oponente movendo...';
        }
      }

      // ===== GERENCIAR CLIQUES NAS C√âLULAS =====
      cells.forEach((cell, i) => {
        const value = board[i];
        
        if (placementPhase) {
          // FASE DE COLOCA√á√ÉO: s√≥ pode clicar em c√©lulas vazias e se for sua vez
          cell.disabled = !myTurn || value !== '';
        } else {
          // FASE DE MOVIMENTO
          if (!myTurn) {
            // Se n√£o √© sua vez, desabilita tudo
            cell.disabled = true;
          } else {
            if (selectedPiece === null) {
              // Sem pe√ßa selecionada: pode clicar apenas nas suas pr√≥prias pe√ßas
              cell.disabled = value !== mySymbol;
            } else {
              // Com pe√ßa selecionada: pode clicar apenas em c√©lulas vazias para mover
              cell.disabled = value !== '';
            }
          }
        }
      });

      // ===== INDICADOR VISUAL DE VEZ =====
      // Adiciona classe 'active' no card do jogador que est√° jogando (brilho/destaque)
      document.getElementById('player1Card').classList.toggle('active', room.current_turn === 'host');
      document.getElementById('player2Card').classList.toggle('active', room.current_turn === 'guest');

      // ===== VERIFICAR VIT√ìRIA =====
      if (room.winner) {
        // Se h√° um vencedor, verifica se foi voc√™ ou o oponente
        const iWon = (isHost && room.winner === 'host') || (!isHost && room.winner === 'guest');
        
        // Atualiza mensagem e cor conforme resultado
        document.getElementById('gameStatus').textContent = iWon ? 'üéâ Voc√™ venceu!' : 'üòî Voc√™ perdeu!';
        document.getElementById('gameStatus').style.background = iWon ? 'rgba(46, 213, 115, 0.3)' : 'rgba(255, 107, 107, 0.3)';
        document.getElementById('phaseInfo').textContent = 'Jogo finalizado!';
        
        // Desabilita todas as c√©lulas e limpa sele√ß√£o
        cells.forEach(c => c.disabled = true);
        selectedPiece = null;
      }
    }

    // ===== LIDAR COM CLIQUE NAS C√âLULAS =====
    async function handleCellClick(index) {
      // Busca estado atual da sala
      const { data: room } = await supabase
        .from('rooms')
        .select('*')
        .eq('id', roomCode)
        .single();

      if (!room) return;

      const board = room.board;                          // Tabuleiro atual
      const mySymbol = isHost ? 'X' : 'O';              // Meu s√≠mbolo
      const xPieces = board.filter(cell => cell === 'X').length;
      const oPieces = board.filter(cell => cell === 'O').length;
      const placementPhase = xPieces < 3 || oPieces < 3;  // Verifica fase

      if (placementPhase) {
        // ===== FASE DE COLOCA√á√ÉO =====
        // N√£o pode colocar em c√©lula ocupada
        if (board[index] !== '') return;

        // Cria novo tabuleiro com a pe√ßa colocada
        const newBoard = [...board];
        newBoard[index] = mySymbol;

        // Verifica se algu√©m ganhou
        const winner = checkWinner(newBoard);
        
        // Alterna a vez para o outro jogador
        const nextTurn = isHost ? 'guest' : 'host';

        // Atualiza o banco de dados
        await supabase
          .from('rooms')
          .update({ 
            board: newBoard,              // Novo estado do tabuleiro
            current_turn: nextTurn,       // Pr√≥ximo jogador
            winner: winner,               // Se algu√©m ganhou
            status: winner ? 'finished' : 'playing'  // Status do jogo
          })
          .eq('id', roomCode);

      } else {
        // ===== FASE DE MOVIMENTO =====
        if (selectedPiece === null) {
          // PASSO 1: SELECIONAR PE√áA PARA MOVER
          if (board[index] === mySymbol) {
            selectedPiece = index;        // Armazena qual pe√ßa foi selecionada
            updateBoard();                // Atualiza para mostrar destaque amarelo
          }
        } else {
          // PASSO 2: MOVER PE√áA SELECIONADA
          if (board[index] === '') {
            // Destino est√° vazio, pode mover
            const newBoard = [...board];
            newBoard[selectedPiece] = '';         // Remove da posi√ß√£o antiga
            newBoard[index] = mySymbol;           // Coloca na nova posi√ß√£o
            selectedPiece = null;                 // Limpa sele√ß√£o

            // Verifica vit√≥ria
            const winner = checkWinner(newBoard);
            const nextTurn = isHost ? 'guest' : 'host';

            // Atualiza banco de dados
            await supabase
              .from('rooms')
              .update({ 
                board: newBoard,
                current_turn: nextTurn,
                winner: winner,
                status: winner ? 'finished' : 'playing'
              })
              .eq('id', roomCode);
              
          } else if (board[index] === mySymbol) {
            // Clicou em outra pe√ßa sua: troca a sele√ß√£o
            selectedPiece = index;
            updateBoard();
          }
        }
      }
    }

    // ===== VERIFICAR VENCEDOR =====
    // Checa todas as combina√ß√µes poss√≠veis de vit√≥ria (linhas, colunas, diagonais)
    function checkWinner(board) {
      const lines = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8],  // Linhas horizontais
        [0, 3, 6], [1, 4, 7], [2, 5, 8],  // Colunas verticais
        [0, 4, 8], [2, 4, 6]              // Diagonais
      ];

      // Para cada combina√ß√£o, verifica se as 3 posi√ß√µes t√™m o mesmo s√≠mbolo
      for (let line of lines) {
        const [a, b, c] = line;
        if (board[a] && board[a] === board[b] && board[a] === board[c]) {
          // Retorna quem ganhou (host se for X, guest se for O)
          return board[a] === 'X' ? 'host' : 'guest';
        }
      }

      // Ningu√©m ganhou ainda
      return null;
    }

    // ===== SAIR DO JOGO =====
    async function leaveGame() {
      // Cancela inscri√ß√£o em tempo real
      if (subscription) subscription.unsubscribe();
      
      // Se for o host, deleta a sala do banco
      if (isHost) {
        await supabase.from('rooms').delete().eq('id', roomCode);
      }
      
      // Limpa dados salvos e volta para tela inicial
      localStorage.clear();
      window.location.href = 'index.html';
    }

    // ===== INICIAR O JOGO =====
    // Quando a p√°gina carrega, inscreve-se nas atualiza√ß√µes
    subscribeToGame();
  </script>
</body>
</html>
